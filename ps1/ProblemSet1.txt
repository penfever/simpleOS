			    Problem Set 1

		 Harvard Extension School CSCI E-92:
	    Principles of Operating Systems - Spring 2021

	 Due: February 14, 2021 at Midnight ET (Eastern Time)


As described in the syllabus, submit the solution to all problems in
this Problem Set using "git" with named branch problem-set-1.

1. (5 Points) Multiprogramming.  What is multiprogramming?  (Also in
   Tanenbaum 3/e 1.1, Tanenbaum 2/e 1.2).  In additon, give at least
   two reasons for having multiprogramming.

Multiprogramming, which first appeared in third generation operating systems such as the IBM OS/360, is partitioning of memory to reduce wait times on I/O-bound operations, which was frequently 80 to 90 percent of the total run time for a commercial data processing applications of that era. 

The implementation is as follows: the system's available memory is divided into an arbitrary number of partitions. The first of these is allocated to the operating system. The remaining partitions are assigned to processes, and are sized by the OS according to the needs of that process.

The first important reason for implementing multiprogramming in an Operating System is that it allows the CPU to be utilized at (potentially) full capacity while waiting on an I/O-bound process. The CPU can simply context switch to a ready process, loading it into the Program Counter and executing that process's next instruction.

Multiprogramming also allows a single user, or a group of users, to run as many programs as the operating system has resources to support, thereby increasing the productivity of that system. This is particularly true for single user systems, where the majority of open programs are idle most of the time, waiting on user input.
 
2. (5 Points) Protected kernel mode operations.  Tanenbaum 4/e 1.12
   (Tanenbaum 3/e 1.7, Tanenbaum 2/e 1.8).  In addition, for each
   subsection a-d, describe what problems would be caused by allowing
   the instruction to run when not in kernel mode.

(a) Disable all interrupts. Kernel mode only. Disabling all interrupts in user mode would prevent the operating system from doing its jobs. User mode programs, unaware of the demands of hardware resources or the current state of the system, would not be able to correctly manage and prioritize incoming requests. This would almost certainly cause a catastrophic crash.

(b) Read the time-of-day clock. Kernel mode only. If the user was allowed to access the clock function without restriction, malicious or poorly designed code could corrupt or alter the clock using the elevated privileges of the kernel.

(c) Set the time-of-day clock. Kernel mode only. The clock is used in Unix for filesystem timestamps, logging, daemons, scheduling, and many other processes. Changing it could disrupt some or all of those functions.

(d) Change the memory map. Kernel mode only. Allowing this instruction to run in user mode could enable a malicious user to access and corrupt protected memory regions, including those of the operating system itself. More likely, however, it would simply cause a catastrophic crash.

3. (5 Points) Priority inversion problem with priority scheduling
   vs. round-robin scheduling.  Tanenbaum 4/e 2.26 (Tanenbaum 3/e
   2.20, Tanenbaum 2/e 2.26) 

The priority inversion problem can be envisioned in a computer with two processes: H and L.   The scheduling rules are such that H runs whenever it is in ready state. At a certain moment, with L in its critical region, H becomes ready to run (e.g., an I/O operation completes). But since L is never scheduled when H is running, L is locked inside the critical region and H is locked out of it, causing both L and H to wait forever.

The reason this can occur in priority scheduling systems is because H, being a higher priority process, always pre-empts L. Workarounds do exist -- for instance, the scheduler may decrease the priority of the currently running process intermittently.

However, a round robin system would not encounter this problem. In RR, each process is assigned a time quantum. If the process is still running at the end of the quantum, the CPU is preempted and given to another process. If the process blocks or finishes, this, too, causes a CPU switch. Therefore, assuming this round robin scheduler also had priority scheduling, H would preempt L, being higher priority, but after H's quantum elapsed, L would resume control of the CPU and leave the critical region.

4. (5 Points) Implementing semaphores using a disable interrupts
   instruction.  Tanenbaum 4/e 2.31 (Tanenbaum 3/e 2.25, Tanenbaum 2/e
   2.23).  You must include pseudo-code for your solution.

An operating system that can disable interrupts can implement semaphore DOWN and UP as atomic, uninterruptible functions. In so doing, certain potential deadlock situations can be avoided. In order to do this, when a semaphore DOWN or UP operation begins, the operating system must disable interrupts until the DOWN or UP operation is complete.

A pseudo-code implementation of this might look something like: 

typedef int semaphore

int DOWN(*semaphore) {
	if (*semaphore > 0)
		*semaphore -= 1
		return 0
	else
		while (*semaphore == 0){
			sleep(1);
}
		DOWN(*semaphore)	
}

int UP(*semaphore) {
	*semaphore += 1
}

int crit_func(*semaphore){
	if (DOWN(*semaphore) == 0){
		sleep(10) //insert cool, critical behavior here
		UP(*semaphore)
	}
	return 0
}

int main() 
{
	pthread_t t1, t2
	semaphore mutex = 1
   	pthread_create(&t1,NULL,crit_func(&mutex),NULL)
       pthread_create(&t2,NULL,crit_func(&mutex),NULL)
    	pthread_join(t1,NULL)
    	pthread_join(t2,NULL)
    	return 0
} 


5. (10 Points) Implementing counting semaphores using binary
   semaphores.  Tanenbaum 4/e 2.32 (Tanenbaum 3/e 2.26, Tanenbaum 2/e
   2.24).  You must include pseudo-code for your solution.  By
   "ordinary machine instructions," we mean all facilities that are
   available through the C Programming Language, for example.  Your
   solution should use binary semaphores wherever mutual exclusion is
   needed.

Show how counting semaphores (i.e., semaphores that can hold an arbitrary value) can be implemented using only binary semaphores and C. Your solution should use binary semaphores wherever mutual exclusion is needed.

#define N 100
typedef int semaphore
semaphore mutex = 1
semaphore empty = N
semaphore full = 0

int DOWN(*semaphore) {
	if (*semaphore > 0)
		*semaphore -= 1
		return 0
	else
		while (*semaphore == 0){
			sleep(10);
}
		DOWN(*semaphore)	
}

int UP(*semaphore) {
       *semaphore += 1
}

void producer(void){
	int item

	while(TRUE){
		item = produce_item()
		DOWN(&empty)
		DOWN(&mutex)
		insert_item(item)
		UP(&mutex)
		UP(&full)
       }
}

void consumer(void){
	int item

	while(TRUE){
		DOWN(&full)
		DOWN(&mutex)
		item = remove_item()
		UP(&mutex)
		UP(&empty)
		consume_item(item)
       }
}


6. (70 Points) Simple Shell Implementation

   Using the C Programming Language on the cscie92.dce.harvard.edu
   instance, implement a simple shell.  Your program should interact
   with the user through stdin, stdout, and stderr.  After outputting
   to stdout a prompt of "$ ", it will accept a line of text input
   from stdin and parse that line into white space delimited fields.
   You must be able to accept lines with up to 256 characters (not
   including any newline or null termination).  White space will be
   composed of one or more spaces or tabs.  From the input line, an
   integer named "argc" and an array named "argv" will created.  The
   integer argc will contain the count of the number of white space
   separated fields found in the input line.  Any white space before
   the first field must also be ignored.  The array argv will contain
   a list of pointers to copies of each of the fields found in the
   input line as null-terminated strings.  The C Standard also
   requires that the argv array contains a final NULL pointer (i.e.,
   argv[argc] is always NULL).

   A declaration of argc and argv follows:

   int argc;
   char **argv;    or, depending on the context:    char *argv[];

   Here is an example.  If the input were to contain:

   echo     this  is some     input   string

   then argc would contain 6 and argv would be an array of seven
   pointers; the first six would point to null terminated strings and
   the seventh pointer would be NULL.  The first pointer would point
   to the string "echo", the second pointer would point to the string
   "this", and so forth.  Note that the argv array needs to be
   dynamically allocated and that each of the strings pointed to by
   each entry in argv needs to be dynamically allocated.  The strings
   pointed to by argv will never contain any spaces or tabs (except if
   either or both of the double-quoting or backslash escape character
   notation extra-credit portions below are implemented).  The space
   allocated for argv should be exactly the required size (i.e., it
   should occupy (argc+1)*sizeof(char *) bytes).  Similarly, the space
   allocated for each string should be exactly the required size
   (i.e., each string should occupy the number of bytes in the string
   + 1 for a null terminating byte).  Storage should be allocated
   using the malloc system call.

   After argc and argv are created, the shell will scan an array named
   "commands" for a match for the first string in argv and will then
   call a different function for each entry in "commands".  That is,
   we will assume that the first word on the line in the name of a
   program to be invoked by the shell.

   A declaration of commands with the initialization of five commands
   as follows:

   int cmd_date(int argc, char *argv[]);
   int cmd_echo(int argc, char *argv[]);
   int cmd_exit(int argc, char *argv[]);
   int cmd_help(int argc, char *argv[]);
   int cmd_clockdate(int argc, char *argv[]);

   struct commandEntry {
     char *name;
     int (*functionp)(int argc, char *argv[]);
   } commands[] = {{"date", cmd_date},
                   {"echo", cmd_echo},
                   {"exit", cmd_exit},
                   {"help", cmd_help},
                   {"clockdate", cmd_clockdate}};

   After a command returns to the shell, all storage allocated for
   argv and the strings that argv points to should be freed.  After
   the storage is freed, the shell should loop back to prompt the user
   for another input line.

   You should implement five commands.  (1) "exit" will exit from the
   shell (i.e., cause the shell to terminate) by calling the exit
   system call.  (2) "echo" will output each of the arguments in argv
   (except for the first) to stdout with a single space character
   between the arguments.  After the last argument is output, a
   newline should be output.  (3) "help" will output to stdout a brief
   description of the commands accepted by the shell.  (4) "date" will
   output to stdout the current date and time in the format "January
   23, 2014 15:57:07.123456".  "date" will call the POSIX system call
   "gettimeofday" to determine the time and date.  "gettimeofday"
   returns the number of seconds and microseconds since midnight (zero
   hours) on January 1, 1970 -- this time is referred to as the Unix
   Epoch.  Your output should be printed in the same timezone as that
   returned by the system call "gettimeofday".  That is, the timezone
   information from gettimeofday should be ignored.  (5) Finally,
   "clockdate" will take a single positive integral number as its
   required argument: that argument will represent the number of
   seconds since the Unix Epoch.  When calling your function to create
   a formatted date, you should pass the number of microseconds since
   the Unix Epoch as zero.  The "clockdate" command will output to
   stdout the date represented by the argument integer in the format
   described in (4) above.  The "clockdate" command is present to
   facilitate our ability to test your conversion from seconds and
   microseconds since the Unix Epoch to a printable human-readable
   string.

   Each command should return an integer to indicate if it succeeded
   or failed and a specific error code on failure.  A value of 0 will
   indicate success and a non-zero value will indicate failure.  You
   should create your own enumerated type of error codes for different
   errors.  If the return value is non-zero, the shell should output
   the value of that return value.  All error messages should be
   output to stderr.

   Each command should check that the appropriate number of arguments
   are specified on the command line.  If no arguments are appropriate
   for a command, then command should guarantee that no arguments have
   been specified.  The "echo" command accepts any number of arguments
   (including none), so no argument count checking is required.

   Your translation from seconds and microseconds since zero hours on
   January 1, 1970 into year, month, day, hours, minutes, seconds, and
   millionths of seconds must be written from scratch using no system
   functions.  Keep in mind that some years are leap years and others
   are not.  Leap years contain 366 days (February 29th) and all other
   years contain 365 days.  Every year that is evenly divisible by
   four is a leap year, except that every year divisible by 100 is not
   a leap year, except that every year divisible by 400 is a leap
   year.

   Your code may use only the following systems calls or library
   functions:
     malloc
     free
     exit
     fgetc
     feof
     ferror
     fputc
     fputs
     fprintf
     sprintf
     snprintf
     vsprintf
     vsnprintf
     gettimeofday
   You are also welcome to use the following library functions
   declared in string.h:
     memcpy
     memmove
     strcpy
     strncpy
     strcat
     strncat
     memcmp
     strcmp
     strncmp
     memchr
     strchr
     strcspn
     strpbrk
     strrchr
     strspn
     strstr
     strtok
     memset
     strerror
     strlen
     
   You may use only stdin, stdout, and stderr as I/O streams.

   (5 Points) Extra credit to be used for the programming portion
   only: Allow fields on the line to be double-quote delimited strings
   that can contain spaces or tabs.  Ensure that any such field has a
   matching open double-quote and close double-quote.  Also, allow a
   double-quote to appear within a double-quoted field in either or
   both of two possible ways: (1) allow two adjacent double-quotes
   within a double-quoted field to denote a single double-quote within
   the field, (2) implement the following backslash escape notation to
   allow special characters within a double-quoted string.

   (5 Points) Extra credit to be used for the programming portion
   only: Implement special backslash escape characters for shell
   command arguments (either outside or inside double-quoted string
   arguments).  If this is implemented, then the backslash character
   would serve as a prefix for the next character.  These two
   characters would then be replaced with a designated single
   character in the argument.  The character after the backslash would
   indicate what character would be designated to be used in the
   argument as follows:

     Escape sequence	Designated replacement character
     \0			null (ASCII 0)
     \a			alarm (bell) (control-g) (ASCII 7)
     \b			backspace (control-h) (ASCII 8)
     \e			escape (ASCII 27 = 0x1b)
     \f			form-feed (control-l) (ASCII 12 = 0xc)
     \n			newline (line-feed) (control-j) (ASCII 10 = 0xa)
     \r			carriage-return (control-m) (ASCII 13 = 0xd)
     \t			horizontal-tab (control-i) (ASCII 9)
     \v			vertical-tab (control-k) (ASCII 11 = 0xb)

   If the character following the backslash is not shown in the table
   above, then the character following the backslash should be used
   literally.  Obviously, this would include the double-quote and
   backslash characters.

   (Points Vary) Extra credit to be used for the programming portion
   only: Add additional built-in commands to your shell.  None of the
   commands you add should require use of files.

   (20 Points) Extra credit to be used for the programming portion
   only: Add variables to your shell.  You should have a "set" command
   to define a variable and to output all defined environment
   variables.  If the "set" command is invoked with no arguments, it
   will display the values of all shell variables.  If the "set"
   command is invoked in the format "set <variable>=<value>", then the
   shell variable <variable> is defined with the value <value> as a
   string.  Variable names may consist of letters and digits starting
   with a letter.  In variable names, the underscore character is
   treated as a letter.  You should not impose any constraints on the
   length of either variable names or of their values.  The value
   field may optionally be enclosed in double-quotes.  If any command
   line contains a dollar-sign followed by the name of a variable,
   then the value of the variable is substituted for its name -- this
   includes a possible substitution at the beginning of the command
   line where the command name would appear.  When this substitution
   phase is being performed, the name of a variable within a command
   line is terminated by a non-alphabetic and non-numeric character.
   It is an error to reference a variable which is not set.  You
   should also implement the shell command "unset" which is invoked in
   the format "unset <variable>" to remove a variable from being
   defined in the shell.


			Last revised 8-Feb-21

